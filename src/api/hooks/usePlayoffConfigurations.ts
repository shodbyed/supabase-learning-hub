/**
 * @fileoverview Playoff Configurations API Hooks
 *
 * TanStack Query hooks for fetching and managing playoff configurations.
 * Supports fetching configurations at any level: global, organization, or league.
 *
 * The entity_type + entity_id pattern allows a single hook to work across all levels:
 * - Global templates: entity_type='global', entity_id='00000000-0000-0000-0000-000000000000'
 * - Organization configs: entity_type='organization', entity_id=orgId
 * - League configs: entity_type='league', entity_id=leagueId
 */

import { useQuery } from '@tanstack/react-query';
import { supabase } from '@/supabaseClient';

/**
 * Nil UUID used for global templates
 * This UUID cannot be generated by UUID v4 (RFC 4122), ensuring no collision
 */
export const GLOBAL_ENTITY_ID = '00000000-0000-0000-0000-000000000000';

/**
 * Entity types for playoff configurations
 */
export type PlayoffConfigEntityType = 'global' | 'organization' | 'league';

/**
 * Playoff configuration record from database
 */
export interface PlayoffConfiguration {
  id: string;
  entity_type: PlayoffConfigEntityType;
  entity_id: string;
  name: string;
  description: string | null;
  is_default: boolean;
  qualification_type: 'all' | 'fixed' | 'percentage';
  fixed_team_count: number | null;
  qualifying_percentage: number | null;
  percentage_min: number | null;
  percentage_max: number | null;
  playoff_weeks: number;
  week_matchup_styles: string[];
  wildcard_spots: number;
  payment_method: 'automatic' | 'manual';
  auto_generate: boolean;
  created_at: string;
  updated_at: string;
}

/**
 * Resolved playoff configuration for a league (from the view)
 */
export interface ResolvedPlayoffConfig {
  league_id: string;
  organization_id: string;
  config_source: 'league' | 'organization' | 'global';
  config_id: string;
  name: string;
  description: string | null;
  qualification_type: 'all' | 'fixed' | 'percentage';
  fixed_team_count: number | null;
  qualifying_percentage: number | null;
  percentage_min: number | null;
  percentage_max: number | null;
  playoff_weeks: number;
  week_matchup_styles: string[];
  wildcard_spots: number;
  payment_method: 'automatic' | 'manual';
  auto_generate: boolean;
}

/**
 * Fetch playoff configurations by entity type and ID
 *
 * @param entityType - The type of entity ('global', 'organization', 'league')
 * @param entityId - The UUID of the entity (use GLOBAL_ENTITY_ID for global)
 * @returns Array of playoff configurations for the entity
 *
 * @example
 * // Fetch global templates
 * const { data } = usePlayoffConfigurations('global', GLOBAL_ENTITY_ID);
 *
 * @example
 * // Fetch organization configurations
 * const { data } = usePlayoffConfigurations('organization', orgId);
 *
 * @example
 * // Fetch league configurations
 * const { data } = usePlayoffConfigurations('league', leagueId);
 */
export const usePlayoffConfigurations = (
  entityType: PlayoffConfigEntityType,
  entityId: string | undefined
) => {
  return useQuery({
    queryKey: ['playoff-configurations', entityType, entityId],
    queryFn: async (): Promise<PlayoffConfiguration[]> => {
      if (!entityId) {
        return [];
      }

      const { data, error } = await supabase
        .from('playoff_configurations')
        .select('*')
        .eq('entity_type', entityType)
        .eq('entity_id', entityId)
        .order('is_default', { ascending: false }) // Default first
        .order('name', { ascending: true });

      if (error) {
        throw new Error(`Failed to fetch playoff configurations: ${error.message}`);
      }

      return data || [];
    },
    enabled: !!entityId,
    // Refetch when mounting if data is stale (important after cache invalidation)
    refetchOnMount: true,
    // Config data doesn't change frequently, but should be fresh when viewing
    staleTime: 60 * 1000, // 1 minute
  });
};

/**
 * Fetch all global playoff templates
 *
 * Convenience hook for fetching system-wide templates.
 * These are read-only for operators and serve as the base defaults.
 *
 * @example
 * const { data: templates, isLoading } = useGlobalPlayoffTemplates();
 */
export const useGlobalPlayoffTemplates = () => {
  return usePlayoffConfigurations('global', GLOBAL_ENTITY_ID);
};

/**
 * Fetch the resolved/effective playoff configuration for a league
 *
 * Uses the resolved_league_playoff_config view which applies the priority chain:
 * league config → organization default → global default
 *
 * @param leagueId - The league's UUID
 * @returns The effective configuration for the league with source info
 *
 * @example
 * const { data: config } = useResolvedPlayoffConfig(leagueId);
 * // config.config_source === 'organization' means using org default
 * // config.name === 'Money Round'
 */
export const useResolvedPlayoffConfig = (leagueId: string | undefined) => {
  return useQuery({
    queryKey: ['resolved-playoff-config', leagueId],
    queryFn: async (): Promise<ResolvedPlayoffConfig | null> => {
      if (!leagueId) {
        return null;
      }

      const { data, error } = await supabase
        .from('resolved_league_playoff_config')
        .select('*')
        .eq('league_id', leagueId)
        .single();

      if (error) {
        // If no config found, return null instead of throwing
        if (error.code === 'PGRST116') {
          return null;
        }
        throw new Error(`Failed to fetch resolved playoff config: ${error.message}`);
      }

      return data;
    },
    enabled: !!leagueId,
    // Refetch when mounting if data is stale (important for inheritance chain updates)
    // This ensures league pages show updated org/global defaults after they change
    refetchOnMount: true,
    // Config data doesn't change frequently, but should be fresh when viewing
    staleTime: 60 * 1000, // 1 minute
  });
};

/**
 * Fetch a single playoff configuration by ID
 *
 * @param configId - The configuration's UUID
 * @returns The playoff configuration
 *
 * @example
 * const { data: config } = usePlayoffConfiguration(configId);
 */
export const usePlayoffConfiguration = (configId: string | undefined) => {
  return useQuery({
    queryKey: ['playoff-configuration', configId],
    queryFn: async (): Promise<PlayoffConfiguration | null> => {
      if (!configId) {
        return null;
      }

      const { data, error } = await supabase
        .from('playoff_configurations')
        .select('*')
        .eq('id', configId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return null;
        }
        throw new Error(`Failed to fetch playoff configuration: ${error.message}`);
      }

      return data;
    },
    enabled: !!configId,
  });
};
